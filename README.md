# Algumas regras
1. CorrelationId nos vários modelos é obrigatório
2. A classe da StateMachine, tem de implementar `MassTransitStateMachine<TSagaStateMachineInstance>` e não permite injetar `DbContext` no Construtor por isso precisas de criar uma `Activity` para poderes persistir coisas.
3. Uma `Activity` tem de ser marcada com `IStateMachineActivity<TSagaStateMachineInstance, TEventThatTriggersIt>`
4. Por causa do ponto 2, a StateMachine apenas faz tracking da class que esteja marcada como `SagaStateMachineInstance`, que tem como obrigatório o atributo `CorrelationId` e atualiza o seu estado quando se chama o `TransitionTo(...)` . Pelo que li no código que é chamado pela biblioteca, os estados vão sendo atualizados (adicionados ao ChangeTracker) mas é tudo mantido em memória até ao final da Saga e só aí é que é commited. Como isto me parece estranho ser assim, ainda estou a investigar.
5. É obrigatório criar um `ISagaClassMap` que represente o modelo da `SagaStateMachineInstance` mas não é obrigatório mapear o `CorrelationId`
6. A DbContext implementar `SagaDbContext` e por isso no override do método Configure tens de devolver a instancia do `ISagaClassMap`
7. Como tudo tem `CorrelationId` e estou a publicar novos eventos do mesmo tipo que estão registados como `Event<out TMessage>` a saga funciona até ao final. Qualquer coisa que fuja disso, tens de criar consumer à parte, ele tem de consumir a mensagem publicada, fazer o que tem a fazer e publicar novo evento que bata certo com o next step da Saga.